---
path: '/typescript-basics'
date: '2020-10-07'
title: 'Typescript, The Basics'
author: 'Austin Ftacnik'
featuredImage: raphael-schaller-GkinCd2enIY-unsplash.jpg
---

testing testing


With its gaining popularity and overly passionate fans, I'd wager it would be more difficult to have *not* heard about TypeScript than to have. Up until this point, I've done everything in my power to avoid learning it (ew, Microsoft?) but since I like a challenge, I've decided to use it on my next project. Part of me wanted to know what all of the hype is about and the other part of me figured learning a type safe language would only benefit my as a developer.

For the unfamiliar, TypeScript is a superset of JavaScript and<a href='https://www.typescriptlang.org/'>" extends JavaScript by adding types"</a>.

Even though everything in JavaScript is basically an object, JavaScript still uses types under the hood but doesn't support type safety.

Here are the data types that JavaScript supports:
<ul>
    <li>boolean</li>
    <li>big integer</li>
    <li>null</li>
    <li>number</li>
    <li>string</li>
    <li>symbol</li>
    <li>object</li>
    <li>undefined</li>
    <li>function?</li>
</ul>

And here are the ones that TS brings to the table:

<ul>
    <li>any (basically tells TS to ignore this variable and let me do what I want with it)</li>
    <li>unknown</li>
    <li>never</li>
    <li>void (function that returns undefined)</li>
</ul>

What does this mean? Well, let's say you have a function that takes two parameters.

<!-- ```JavaScript
const add = (a, b) => {
    return a + b
}
``` -->

Without type safety, JavaScript doesn't care what **types** those values are. You could pass the function `Dog` and `Cat` as strings and it would still attempt to add them together (which would actually work as you'd be concatenating them but it's likely that wasn't your intended result - otherwise you probably would've named the function "concatenate" or something).

*que typescript*

With TS (short for TypeScript), we can guarantee that *only* the correct types will be passed to the function. This "type safety" results in less bugs later down the road and (sometimes) a more pleasant development experience.

<!-- ```TypeScript
const add = (a: number, b: number) => {
    return a + b
}
``` -->

There are a few different ways to define types but we'll start with the easiest which is inferred types. They're the easiest because you literally don't have to do anything (yay).

### inferred types

<!-- ```JavaScript
const name = 'Austin'
``` -->

TS is smart enough to know that the above is a string. 

### defined types

<!-- ```JavaScript
// string
const name: string = 'Austin'

// number
const age: number = 27

// array
const hobbies: string[] = ['coding', 'reading', 'weight lifting']

``` -->

Pretty straight forward, we're defining the data type when defining the variable.

### type interfaces

<!-- ```TypeScript
interface MyObj {
    name: string,
    age: number
}

const myObj: MyObj = {
    name: 'Austin',
    age: 27
}
``` -->

This almost feels like defining schema in Mongoose to me?

Fun fact numero dos: when I first started learning JavaScript, I thought "types" and "typing" were somehow related. Types weren't a *super* important aspect of JavaScript so it took me a while to realize "types" referred to "data types" ü§¶‚Äç‚ôÇÔ∏è

### composing types

Unions:

<!-- ```TypeScript
type myBool = true | false
``` -->
Unions are a way of saying "this should be one of these types". I immediately thought of enums when learning about unions but apparently they're not the same as they can't be enumerated. Since `myBool` can only be `true` or `false`, it's type is set to boolean.

Here's another example:

<!-- ```TypeScript
type myFriend = 'Devin' | 'Luke' | `Rillo`
``` -->
And once again, TS checks the types and sets `myFriend` to string.

It's also possible to use multiple types, hence the name "unions". 

<!-- ```TypeScript
type myPhoneNumber = 1234567 | '123-4567'
``` -->

Generics:

From the TS documentation "generics provide variables to types"

<!-- ```TypeScript
type MyNames = Array<string>
const myNames: MyNames = ['Austin', 'Ftacnik']

//or 

const yourNames: Array<string> = ['your', 'names']
``` -->
As seen above, with generics we were able to define what the array will contain.

Structural Type System aka Duck Typing:

Allows you use to define the shape of values. If two objects share the same shape, they are considered to be of the same type.

<!-- ```TypeScript
interface Nums {
    a: number,
    b: number,
}

const multiply = (obj: Nums) => {
    return obj.a + obj.b
}

const nums = { a: 2, b: 4}
const result: number = multiply(nums); // 8
``` -->

Notice how we didn't use the `Nums` interface to declare the `nums` type but it still worked correctly because they are of the same shape.

#### Tuple: 

(fixed length array)

<!-- ```TypeScript
let x: [string, number];
x = ['Hello', 8]
``` -->

#### Enums:



<!-- ```TypeScript
enum Colors {
    Red,
    Blue,
    Green
}

const myFavoriteColor = Colors.Green;

const myLeastFavoriteColor = Colors[0]
``` -->



PS - Microsoft, if you're reading this, I was kidding about what I said and I actually like using your products, especially Paint. Please hire me. 

### useful links
<a href='https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html'>TS in 5 minutes from the docs</a>
<a href='https://www.youtube.com/watch?v=se72XMlG1Ro'>Ben Awad video explaining TS basics</a>

